<%
  #TODO: spin off into separate helper file, add tests
  require 'duration'
  def render_percentile(data,timeframe, percentile)
    duration = Duration.new(data[timeframe]["duration_percentiles"]["p#{percentile}"])
    is_smallest = data.min_by{|k,v| v["duration_percentiles"]["p#{percentile}"] rescue 9999.week}.first == timeframe
    "<td><p#{' class="best"' if is_smallest}>#{format_duration(duration)}</p></td>"
  end
  def format_duration(duration)
    return "â€”" if duration == 0
    s = ""
    s += "#{duration.weeks}w " unless duration < 1.week
    s += "#{duration.days}d " unless duration > 4.week || duration < 1.day
    s += "#{duration.hours}h " unless duration > 1.week || duration < 1.hour
    s += "#{duration.minutes}m " unless duration > 6.hours || duration < 1.minute
    s += "#{duration.seconds}s" unless duration > 10.minutes
    s.strip
  end
  this_week = data["this_week"]
%>
<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" type="text/css" href="/ghdata/bootstrap.min.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      table.table p.best{
        font-weight: bold
      }

    svg circle{
      fill: #333;
      opacity: 0.4;
    }

    svg line{
      fill: none;
      stroke: #333;
      shape-rendering: crispEdges;
    }
    </style>
    <link rel="stylesheet" type="text/css" href="/ghdata/nv.d3.min.css" />
    <script src="/ghdata/d3.v3.min.js"></script>
    <script src="/ghdata/queue.v1.min.js"></script>
    <script src="/ghdata/nv.d3.min.js"></script>
  </head>
  <body>
    <h1><%=data["meta"]["owner"]%> / <%=data["meta"]["repo"]%></h1>
    <div class="container-fluid">
      <div class="row">
        <div class="col-md-2"></div>
        <div class="col-md-8">
          <p>
          Lask week, <%=this_week["opened"]%> issues were opened, <%=this_week["opened_and_closed"]%> of which have since been closed.
          Of the <%=this_week["opened"] - this_week["opened_and_closed"]%> still open, <%=data["yesterday"]["opened"]%> <%=data["yesterday"]["opened"] == 1 ? "was" : "were"%> created in the last 24 hours.
          <%=older = this_week["closed"] - this_week["opened_and_closed"]; older == 0 ? "No" : older%> older issues were<%=" also" unless older == 0%> closed last week, leaving <%=data["now"]["open"]%> still open.
          </p>
        </div>
        <div class="col-md-2"></div>
      </div>
      <div class="row">

        <table class="table">
          <thead>
            <tr>
              <th>Closed during</th>
              <th>25</th>
              <th>50 (Median)</th>
              <th>75</th>
              <th>90</th>
            </tr>
          </thead>
          <tbody>
            <% %w(this_week last_week last_month).each do |t|%>
              <%="<tr>"%>
                <%="<td>#{data[t]["name"] || t.sub('_', ' ').capitalize}</td>"%>
                <%data["meta"]["percentiles"].each do |i|%>
                  <%=render_percentile(data, t, i)%>
                <%end%>
              <%="</tr>"%>
            <%end%>
          </tbody>
        </table>

      </div>
    </div>
    <div id="line_plot"><svg></svg></div>
    <div id="bar_plot"><svg></svg></div>
  </body>
</html>
<script>
  var w = 1000;
  var h =  300;
  var marginH = 60;

  var x = d3.time.scale()
    .range([marginH, marginH+w])
  var y = d3.scale.linear()
    .range([h,0])

  var xAxis = d3.svg.axis()
      .scale(x)
      .tickFormat(d3.time.format("%m/%y"));
  var yAxis = d3.svg.axis()
      .scale(y)
      .orient("left");

  var svg1 = d3.select("div#line_plot svg")
      .attr("width", marginH*2 + w)
      .attr("height", h)

  var svg2 = d3.select("div#bar_plot svg")
      .attr("width", marginH*2 + w)
      .attr("height", h)

  queue()
    .defer(d3.csv,
      <%="\"/ghdata/data/#{data["meta"]["owner"]}_#{data["meta"]["repo"]}_issues_open.csv\""%>,
      function(d){return {timestamp: new Date(+d.timestamp*1000), count: +d.count, open: d.opening == "true", number: +d.number, title: d.title}}
    )
    .defer(d3.csv,
      <%="\"/ghdata/data/#{data["meta"]["owner"]}_#{data["meta"]["repo"]}_durations.csv\""%>,
      function(d){return {timestamp: new Date(+d.timestamp*1000), duration: +d.duration, is_pr: d.is_pr == "true", number: +d.number, title: d.title}}
    ).await(function(error, open_at_time, durations) {
    if(error){return console.log(error);}

    x.domain(d3.extent(open_at_time, function(d){return d.timestamp}));
    y.domain([0, d3.max(open_at_time, function(d){return d.count})]);

    svg1.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0,"+ h +")")
      .call(xAxis);
    svg1.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate("+marginH+",0)")
      .call(yAxis);

    svg1.selectAll("circle")
      .data(open_at_time)
      .enter()
      .append("circle")
      //.attr("class", "connect vary")
      //.filter(function (d) {return d.up != 0 && d.dn != 0;})
      .attr("cx", function(d) { return x(d.timestamp) })
      .attr("cy", function(d) { return y(d.count) })
      .attr("r", 1)


/*
    y = d3.scale.log().range([h,0])
    yAxis.scale(y)
*/
    y.domain([0, d3.max(durations, function(d){return d.duration})]);
    svg2.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0,"+ h +")")
      .call(xAxis);
    svg2.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate("+marginH+",0)")
      .call(yAxis);

    svg2.selectAll("line")
      .data(durations)
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.timestamp) })
      .attr("x2", function(d) { return x(d.timestamp) })
      .attr("y1", function(d) { return y(d.duration) })
      .attr("y2", y(0))

  });

    //d3.csv(<%="\"/ghdata/data/#{data["meta"]["owner"]}_#{data["meta"]["repo"]}_durations.csv\""%>,
    //function(d){return {x: +d.timestamp, y: +d.count, shape: 'circle', open: d.opening == "true", number: +d.number, title: d.title}},
    //function(error, data) {
      //if(error){return console.log(error);}

</script>
