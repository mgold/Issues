<%
  #TODO: spin off into separate helper file, add tests
  require 'duration'
  def render_percentile(data,timeframe, percentile)
    duration = Duration.new(data[timeframe]["duration_percentiles"]["p#{percentile}"])
    is_smallest = data.min_by{|k,v| v["duration_percentiles"]["p#{percentile}"] rescue 9999.week}.first == timeframe
    "<td><p#{' class="best"' if is_smallest}>#{format_duration(duration)}</p></td>"
  end
  def format_duration(duration)
    return "â€”" if duration == 0
    s = ""
    s += "#{duration.weeks}w " unless duration < 1.week
    s += "#{duration.days}d " unless duration > 4.week || duration < 1.day
    s += "#{duration.hours}h " unless duration > 1.week || duration < 1.hour
    s += "#{duration.minutes}m " unless duration > 6.hours || duration < 1.minute
    s += "#{duration.seconds}s" unless duration > 10.minutes
    s.strip
  end
  this_week = data["this_week"]
%>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      table.table p.best{
        font-weight: bold
      }

    svg {
      margin-left: 16px;
    }
    svg circle{
      fill: #333;
      opacity: 0.4;
    }

    .axis {
      pointer-events:none;
    }

    .axis text {
      font-family: sans-serif;
      font-size: 10px;
    }

    .axis path, .axis line {
      fill: none;
      stroke: #333;
      shape-rendering: crispEdges;
    }

    svg line{
      fill: none;
      stroke: #000;
      stroke-opacity: .4;
      shape-rendering: crispEdges;
    }

    input.vertical { -webkit-appearance: slider-vertical; writing-mode: bt-lr;
     float:left;
     width: 0px;
    }
    </style>
    <script src="/ghdata/d3.v3.min.js"></script>
    <script src="/ghdata/queue.v1.min.js"></script>
    <script src="/ghdata/d3.slider.js"></script>
  </head>
  <body>
    <h1><%=data["meta"]["owner"]%> / <%=data["meta"]["repo"]%></h1>
    <div class="container-fluid">
      <div class="row">
        <div class="col-md-2"></div>
        <div class="col-md-8">
          <p>
          Lask week, <%=this_week["opened"]%> issues were opened, <%=this_week["opened_and_closed"]%> of which have since been closed.
          Of the <%=this_week["opened"] - this_week["opened_and_closed"]%> still open, <%=data["yesterday"]["opened"]%> <%=data["yesterday"]["opened"] == 1 ? "was" : "were"%> created in the last 24 hours.
          <%=older = this_week["closed"] - this_week["opened_and_closed"]; older == 0 ? "No" : older%> older issues were<%=" also" unless older == 0%> closed last week, leaving <%=data["now"]["open"]%> still open.
          </p>
        </div>
        <div class="col-md-2"></div>
      </div>
      <div class="row">

        <table class="table">
          <thead>
            <tr>
              <th>Closed during</th>
              <th>25</th>
              <th>50 (Median)</th>
              <th>75</th>
              <th>90</th>
            </tr>
          </thead>
          <tbody>
            <% %w(this_week last_week last_month).each do |t|%>
              <%="<tr>"%>
                <%="<td>#{data[t]["name"] || t.sub('_', ' ').capitalize}</td>"%>
                <%data["meta"]["percentiles"].each do |i|%>
                  <%=render_percentile(data, t, i)%>
                <%end%>
              <%="</tr>"%>
            <%end%>
          </tbody>
        </table>

      </div>
    </div>
    <div id="line_plot"><svg></svg></div>
    <div id="bar_plot">
      <input id="bar_plot_slider" type=range min=604800 class=vertical orient=vertical oninput="redrawBars(value)">
      <svg></svg>
    </div>
  </div>
  </body>
</html>
<script>
  var w = 1000;
  var h =  300;
  var marginH = 40;

  var x = d3.time.scale()
    .range([marginH, marginH+w])
  var y = d3.scale.linear()
    .range([h,0])

  var xAxis = d3.svg.axis()
      .scale(x)
      .tickFormat(d3.time.format("%m/%y"));
  var yAxis = d3.svg.axis()
      .scale(y)
      .orient("left");

  var svg1 = d3.select("div#line_plot svg")
      .attr("width", (marginH*2 + w) + "px")
      .attr("height", 50+h+"px")

  var svg2 = d3.select("div#bar_plot svg")
      .attr("width", (marginH*2 + w) + "px")
      .attr("height", 50+h+"px")

  queue()
    .defer(d3.csv,
      <%="\"/ghdata/data/#{data["meta"]["owner"]}_#{data["meta"]["repo"]}_issues_open.csv\""%>,
      function(d){return {timestamp: new Date(+d.timestamp*1000), count: +d.count, open: d.opening == "true", number: +d.number, title: d.title}}
    )
    .defer(d3.csv,
      <%="\"/ghdata/data/#{data["meta"]["owner"]}_#{data["meta"]["repo"]}_durations.csv\""%>,
      function(d){return {timestamp: new Date(+d.timestamp*1000), duration: +d.duration, is_pr: d.is_pr == "true", number: +d.number, title: d.title}}
    ).await(function(error, open_at_time, durs) {
    if(error){return console.log(error);}

    x.domain(d3.extent(open_at_time, function(d){return d.timestamp}));
    y.domain([0, d3.max(open_at_time, function(d){return d.count})]);

    svg1.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0,"+ h +")")
      .call(xAxis);
    svg1.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate("+marginH+",0)")
      .call(yAxis);

    svg1.selectAll("circle")
      .data(open_at_time)
      .enter()
      .append("circle")
      .attr("cx", function(d) { return x(d.timestamp) })
      .attr("cy", function(d) { return y(d.count) })
      .attr("r", 1)

      y.domain([0, d3.max(durs, function(d){return d.duration})]);
      yAxis.tickFormat(function(d){return d3.format(",.0f")(d/86400)});
      d3.select("#bar_plot_slider")
      .style("height", h + "px")
      .attr("max", y.domain()[1])
      .attr("value", y.domain()[1])

      svg2.style("margin-left", 12)
      svg2.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0,"+ h +")")
        .call(xAxis);
      svg2.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate("+marginH+",0)")
        .call(yAxis);

      durations = durs; // save for later
      redrawBars(y.domain()[1])
    });

    function redrawBars(maxY){
      if (!durations){return}
      y.domain([0, maxY]);
      svg2.select("g.y.axis")
        .call(yAxis);

      svg2.selectAll(".duration").remove()
      svg2.selectAll("nonexistant")
        .data(durations.filter(function(d){return d.duration <= maxY}))
        .enter()
        .append("line")
        .attr("class", "duration")
        .attr("svg:title", function(d){ return d.number })
        .attr("x1", function(d) { return x(d.timestamp) })
        .attr("x2", function(d) { return x(d.timestamp) })
        .attr("y1", function(d) { return y(d.duration) })
        .attr("y2", y(0))

      svg2.selectAll("nonexistant")
        .data(durations.filter(function(d){return d.duration > maxY}))
        .enter()
        .append("circle")
        .attr("class", "duration")
        .attr("svg:title", function(d){ return d.number })
        .attr("cx", function(d) { return x(d.timestamp) })
        .attr("cy", y(maxY) + 4)
        .attr("r", 2)

    }

</script>
